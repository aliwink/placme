#!/usr/bin/perl

# placme - Perl client for the ACME protocol (used by e.g. Let's Encrypt)
# Copyright 2015 Jan KrÃ¼ger
# License: GPL v3 or newer (you choose)

use 5.12.0;
our $VERSION = '0.1';

use autodie;
use strict;
use warnings;

use Carp;
use Digest::SHA;
use File::Path qw(make_path);
use File::Spec;
use File::Temp;
use Getopt::Long;
use IPC::Open2;
use JSON;
use LWP::UserAgent;
use MIME::Base64 qw(encode_base64url decode_base64url encode_base64 decode_base64);
use Pod::Usage;
use Time::Piece;

my $config_dir = File::Spec->catdir($ENV{HOME}, '.config', 'placme');
my $directory;
my $quiet;
my $verbose;
my $trace;
my $machine;
my $keyfile;
my %resources;
my @nonces;

my $friendlyjson;

my $ua = LWP::UserAgent->new;
$ua->agent("placme/$VERSION ");
$ua->protocols_allowed(['https']);

# Helpers {{{
sub out($) {
	print STDERR shift."\n";
}
sub noise($) {
	out shift unless $quiet;
}
sub info($) {
	out shift if $verbose || $trace;
}
sub putdata {
	my $v_only;
	$v_only = shift if ($_[0] // '') eq '-v';

	my ($type, $msg, $data) = @_;
	if ($machine) {
		print "$type $data\n";
	} else {
		printf "$msg\n", $data unless $v_only && !$verbose;
	}
}
sub m_progress($) {
	my $msg = shift;
	print "progress $msg\n" if $machine;
}
sub trace($) {
	out shift if $trace;
}
sub which {
	my @path = File::Spec->path;
	my $bin = shift;
	while (my $p = shift @path) {
		my $candidate = File::Spec->catfile($p, $bin);
		return $candidate if -x $candidate;
	}
	return;
}
sub getdir {
	my ($volume, $dir, $file) = File::Spec->splitpath(File::Spec->rel2abs(@_));
	File::Spec->catpath($volume, $dir, '');
}
sub getparentdir {
	my ($volume, $dir, $file) = File::Spec->splitpath(shift);
	my @dir = File::Spec->splitdir($dir);
	pop @dir;
	$dir = File::Spec->catdir(@dir);
	File::Spec->catpath($volume, $dir);
}
sub slurp {
	my $fn = shift;
	my $chompy = shift;
	local $/;
	open(my $fh, '<', $fn);
	my $res = <$fh>;
	chomp $res if $chompy;
	$res;
}
sub spurt {
	my $fn = shift;
	open(my $fh, '>', $fn);
	print $fh shift;
}
sub cfgfile {
	File::Spec->catfile($config_dir, shift);
}
sub cfgslurp {
	my $fn = shift;
	slurp(cfgfile($fn), @_);
}
sub cfgspurt {
	my $fn = shift;
	spurt(cfgfile($fn), shift);
}
my $exit;
sub tick {
	sys2(undef, @_);
}
sub sys2 {
	my $data = shift;
	trace "Execute: ". to_json(\@_);
	my ($out, $in);
	my $pid = open2($out, $in, @_);
	print $in $data if defined $data;
	close $in;
	local $/;
	my $res = <$out>;
	waitpid $pid, 0;
	$exit = $?;
	die sprintf("I ran %s but it died from signal %d%s",
		$_[0],
		$exit & 127,
		$exit & 128 ? ' (core dumped)' : ''
	) if $exit & 127;
	$exit >>= 8;
	$res;
}
sub openssl {
	my $bin = which('openssl') // die "openssl binary not found in PATH";
	sys2(shift, $bin, @_);
}
# }}}
# Crypto and JWS fun {{{
my $jwk_cached;
sub jwk {
	return $jwk_cached if defined $jwk_cached;
	my $text = openssl(undef, 'pkey',
		'-noout',
		'-text_pub',
		'-in' => $keyfile,
	);
	die "failed extracting JWK parameters from account key" if $exit;
	die "failed extracting modulus from account key" unless $text =~ m!^Modulus:([\s0-9a-f:]+)!ms;
	my $modulus = $1;
	{
		use bytes;
		$modulus =~ s#[^0-9a-f]##g;
		$modulus = pack("H*", $modulus);
		$modulus =~ s!^\x00*!!;
	}
	die "failed extracting exponent from account key" unless $text =~ m!^Exponent: (\d+)!m;
	my $exponent = $1;
	$exponent = pack("N", $exponent);
	$exponent =~ s!^\x00*!!;
	$jwk_cached = {
		kty => 'RSA',
		n => encode_base64url($modulus),
		e => encode_base64url($exponent),
	};
	$jwk_cached;
}
sub jwk_thumbprint {
	my $jwk = jwk();
	my $json = JSON->new->canonical->encode($jwk);
	encode_base64url(Digest::SHA::sha256($json));
}
sub sign {
	my $data = shift;
	my $hash = openssl($data, 'dgst',
		-sign => $keyfile,
		'-sha256',
		'-binary',
	);
	die "failed signing ACME protocol message" if $exit;
	encode_base64url($hash);
}
sub _jws_flattened {
	my $header = shift;
	my %payload = @_;
	$header->{alg} = 'RS256';
	$header->{jwk} = jwk();
	my $prot_header_enc = encode_base64url(encode_json($header));
	my $payload = encode_json(\%payload);
	trace "Generate signed message: $payload, header: ". encode_json($header);
	my $payload_enc = encode_base64url($payload);
	my $signature = sign("$prot_header_enc.$payload_enc");
	my $res = encode_json({
		payload => $payload_enc,
		protected => $prot_header_enc,
		signature => $signature,
	});
	$res;
}
sub jws_nonce {
	_jws_flattened({
		nonce => shift @nonces,
	}, @_);
}
sub jws_flattened {
	_jws_flattened({}, @_);
}
# X.509 {{{
sub mkreq {
	my $tlskey = shift;
	my $dn = $_[0];
	my $names = join(',', map { "DNS:$_" } @_);
	trace "Generating CSR for: $dn ($names) using key $tlskey";
	my $cnf = File::Temp->new(TEMPLATE => "openssl.cnf-XXXXXX", DIR => $config_dir);
	print $cnf "prompt=no\ndistinguished_name=dn\nreq_extensions=reqexts\n[dn]\nCN=$dn\n";
	print $cnf "[reqexts]\nsubjectAltName=$names\n";
	$cnf->flush;
	my $req = openssl(undef, 'req',
		'-new',
		-key => $tlskey,
		-config => $cnf->filename,
		-outform => 'der',
	);
	die "failed to create certificate request" if $exit;
	encode_base64url($req);
}


package Local::DER;

use Carp;
use MIME::Base64;

sub _checkpem {
	my ($pem, $type) = @_;
	$pem =~ /^-----BEGIN \Q$type\E-----([A-Za-z0-9\/\n+=]+)-----END \Q$type\E-----\s*$/ or die "Failed to parse $type PEM file";
	$1 =~ s/=//gr;
}
sub from_pem {
	my ($pem, $type) = @_;
	$pem = _checkpem($pem, uc $type);
	$pem =~ s#\n##g;
	decode_base64($pem);
}
sub to_pem {
	my ($der, $type) = @_;
	if (ref $der) {
		$type //= $der->{type};
		$der = $der->{data};
	}
	confess "Can't convert DER to PEM without knowing the proper type" unless defined $type;
	my $pem = join("\n", grep {$_ ne ''} split(/(.{1,64})/, encode_base64($der, '')));
	"-----BEGIN \U$type\E-----\n$pem\n-----END \U$type\E-----\n";
}
sub cert_from_pem { from_pem(shift, 'certificate'); }
sub cert_to_pem { to_pem(shift, 'certificate'); }
sub key_from_pem { from_pem(shift, 'private key'); }
sub key_to_pem { to_pem(shift, 'private key'); }
sub csr_from_pem { from_pem(shift, 'certificate request'); }
sub csr_to_pem { to_pem(shift, 'certificate request'); }

sub new {
	my $class = shift;
	my $data = shift;
	my $type = shift;
	my $pos = shift // 0;

	if ($data =~ /^\s*-----BEGIN ([^-]+)-----.*^-----END \1-----\s*$/ms) {
		die "Loaded PEM data of type '$1' but expected '$type'" if defined $type && $type ne $1;
		$type = $1;
		$data = from_pem($data, $type);
	}

	bless {
		data => $data,
		pos => $pos,
		type => $type,
	}, $class;
}
sub pem {
	my $self = shift;
	to_pem($self->data, $self->type);
}
sub _moar {
	my $self = shift;
	my $count = shift // 1;
	my $pos = $self->{pos};
	confess "DER parse error: element longer than input at offset $pos" if length($self->{data}) < ($pos + $count);
	$self->{pos} += $count;
	my $res = substr($self->{data}, $pos, $count);
	$res;
}
sub _len {
	my $self = shift;
	my $lpos = $self->pos;
	my $len = ord $self->_moar;
	return $len unless ($len & 0x80);

	# Multi-byte length info
	$len &= 0x7f;
	confess "DER parse error: indefinite length info not allowed in DER at offset $lpos" if $len == 0;
	confess "DER parse error: invalid length information at offset $lpos" if $len == 0x7f;
	confess "DER parse error: sizes > 4 GB not supported at offset $lpos" if $len > 4;
	$len = $self->_moar($len);
	$len = "\0$len" while length($len) < 4;
	unpack('N', $len);
}
sub next {
	my $self = shift;
	my $implicit_tag = shift;
	my $implicit_len = shift;
	my $epos = $self->{pos};
	my ($type, $len);
	
	if (defined $implicit_tag) {
		$type = $implicit_tag;
		$len = $implicit_len;
	} else {
		$type = ord $self->_moar;
		if ($type == 0) {
			$self->{last} = 'EOC';
			return 0;
		}
		$len = $self->_len;
	}

	my $cpos = $self->{pos};
	if ($type == 1) { # BOOLEAN
		croak "DER parse error: BOOLEAN value longer than one byte at offset $epos" unless $len == 1;
		$self->{last} = 'BOOLEAN';
		return ord $self->_moar;
	} elsif ($type == 2) { # INTEGER
		$self->{last} = 'INTEGER';
		my $val = $self->_moar($len);
		my $res = 0;
		for my $c (split(//, $val)) {
			$res *= 256;
			$res += ord($c);
		}
		return $res;
	} elsif ($type == 3) { # BIT STRING
		my $pad = ord $self->_moar;
		croak "DER parse error: bit string with incomplete final octet not supported at offset $epos" if $pad != 0;
		$self->{last} = 'BIT STRING';
		return $self->_moar($len-1);
	} elsif ($type == 4) { # OCTET STRING
		$self->{last} = 'OCTET STRING';
		return $self->_moar($len);
	} elsif ($type == 5) { # NULL
		croak "DER parse error: non-empty NULL value at offset $epos" unless $len == 0;
		$self->{last} = 'NULL';
		return 0;
	} elsif ($type == 6) { # OBJECT IDENTIFIER
		my @out;
		my $first = ord $self->_moar;
		push @out, int($first / 40), ($first % 40);
		my $rest = $self->_moar($len - 1);
		push @out, unpack('w*', $rest) if $len > 1;
		$self->{last} = 'OBJECT IDENTIFIER';
		return join('.', @out);
	} elsif ($type == 0x0c) { # UTF8String
		$self->{last} = 'UTF8String';
		return Encode::decode_utf8($self->_moar($len));
	} elsif ($type == 0x0d) { # RELATIVE-OID
		$self->{last} = 'RELATIVE-OID';
		return join('.', unpack('w*', $self->_moar($len)));
	} elsif ($type == 0x13) { # PrintableString
		$self->{last} = 'PrintableString';
		return $self->_moar($len);
	} elsif ($type == 0x16) { # IA5String
		$self->{last} = 'IA5String';
		return $self->_moar($len);
	} elsif ($type == 0x17) { # UTCTime
		my $str = $self->_moar($len);
		$self->{last} = 'UTCTime';
		if ($str =~ /(.*)Z$/) {
			return Time::Piece->strptime($1, "%y%m%d%H%M%S")->epoch if $len eq 13;
			return Time::Piece->strptime($1, "%y%m%d%H%M")->epoch;
		}
		return Time::Piece->strptime($str, "%y%m%d%H%M%S%z")->epoch if $len eq 17;
		return Time::Piece->strptime($str, "%y%m%d%H%M%z")->epoch;
	} elsif ($type == 0x18) { # GeneralizedTime
		my $str = $self->_moar($len);
		my ($format, $offset) = ('%Y%m%d%H', 0);
		my ($dt, $tz, $tzval) = split(/([Z+-])/, $str);
		($dt, $offset) = split(/\./, $dt, 2);
		$offset //= 0;
		$offset = "0.$offset" if $offset;
		if ($dt =~ /^\d{10}$/) { # YYYYmmddHH
			$offset *= 3600;
		} elsif ($dt =~ /\d{12}$/) { # YYYYmmddHHMM
			$format .= '%M';
			$offset *= 60;
		} else {
			$format .= '%M%S';
		}
		$self->{last} = 'GeneralizedTime';
		return Time::Piece->new->strptime($dt, $format) + $offset unless $tz; # undocumented way to signal localtime
		return Time::Piece->strptime($dt, $format) + $offset if $tz eq 'Z';
		my $val = Time::Piece->strptime($dt, $format) + $offset;
		my ($hr, $min) = ($tzval =~ /^(\d\d)(\d\d)$/);
		if ($tz eq '+') {
			$val += ($hr * 3600) + ($min * 60);
		} else {
			$val -= ($hr * 3600) + ($min * 60);
		}
		return $val;
	} elsif ($type == 0x30) { # SEQUENCE/SEQUENCE OF (0x10 | constructed 0x20)
		$self->{last} = 'SEQUENCE';
		return Local::DER->new($self->_moar($len));
	} elsif ($type == 0x31) { # SET/SET OF (0x11 | constructed 0x20)
		$self->{last} = 'SET';
		return Local::DER->new($self->_moar($len));
	} elsif (($type & 0xf0) == 0xa0) { # sequence identifier
		$self->{last} = '_identifier';
		return [$type & 0x1f, Local::DER->new($self->_moar($len))];
	} elsif (($type & 0xf0) == 0x80) { # application-specific tag
		$self->{last} = '_apptag';
		return [$type & 0x1f, Local::DER->new($self->_moar($len))];
	}
}
sub next_as {
	my ($self, $val, $msg) = @_;
	my $res = $self->next;
	return $res if $self->{last} eq $val;
	confess $msg;
}
sub next_rawint {
	my $self = shift;
	my $type = ord $self->_moar;
	confess "DER parse error: expected INTEGER but got tag $type" unless $type == 2;
	my $len = $self->_len;
	$self->_moar($len);
}
sub last { shift->{'last'}; }
sub pos { shift->{'pos'}; }
sub end {
	my $self = shift;
	$self->{pos} == length $self->{data};
}
sub data { shift->{data}; }
sub type { shift->{type}; }
sub next_seq {
	my ($self, $type) = @_;
	my $res = $self->next_as('SEQUENCE', "DER parse failed: expected '$type' sequence but got random garbage");
}
sub next_set {
	my ($self, $type) = @_;
	my $res = $self->next_as('SET', "DER parse failed: expected '$type' set but got random garbage");
}
sub cert_info {
	my $self = shift;
	my $c = $self->next_seq('Certificate');
	$c = $c->next_seq('TBSCertficate');
	my $res = {
		version => 0,
	};

	# version
	my $elem = $c->next;
	croak "Invalid certificate: default X.509 version (v1) used and we support only v3" unless $c->last eq '_identifier' && $elem->[0] == 0;
	$elem = $elem->[1];
	$res->{version} = $elem->next;
	croak "Invalid certificate: X.509 version is not v3 (we support only that)" unless $elem->last eq 'INTEGER' && $res->{version} == 2; # 2 = v3

	# serialNumber
	$elem = $c->next_as('INTEGER', "Invalid certificate: expected serialNumber, got something else");

	# signature
	$elem = $c->next_seq('signature');

	# issuer
	$elem = $c->next_seq('issuer');

	# validity (finally something useful)
	$elem = $c->next_seq('validity');
	my $from = $elem->next;
	croak "Invalid certificate: expected 'valid not before', got something else" unless $elem->last =~ /^(?:UTC|Generalized)Time$/;
	$res->{validfrom} = $from;
	my $to = $elem->next;
	croak "Invalid certificate: expected 'valid not after', got something else" unless $elem->last =~ /^(?:UTC|Generalized)Time$/;
	$res->{validto} = $to;

	# subject
	$elem = $c->next_seq('subject');
	$elem = $elem->next_set('subject');
	while (my $rdn = $elem->next_seq('subject attribute')) {
		my $oid = $rdn->next;
		next unless $oid eq '2.5.4.3'; # cn
		$res->{cn} = $rdn->next;
		last;
	}

	# subjectPublicKeyInfo
	$elem = $c->next_seq('subjectPublicKeyInfo');
	my $pki = $elem->next_seq('algorithm');
	my $algid = $pki->next;
	croak "Unsupported certificate: public key type isn't RSA" unless $algid eq '1.2.840.113549.1.1.1';
	$pki->next_as('NULL', "Unsupported certificate: RSA parameter isn't NULL, unlike specified in PKCS#1");
	$pki = $elem->next_as('BIT STRING', "Invalid certificate: public key data in unexpected format");
	$pki = Local::DER->new($pki);
	$pki = $pki->next_seq("Invalid certificate: public key data doesn't contain public key container");
	my $mod = $pki->next_as('INTEGER', "Invalid certificate: modulus not found in public key data");
	my $exp = $pki->next_as('INTEGER', "Invalid certificate: exponent not found in public key data");

	# optional fields
	while ($elem = $c->next) {
		croak "Invalid certificate: found trailing element that is not one of the valid optional elements" unless $c->last eq '_identifier' && grep {$_ == $elem->[0]} (1,2,3);
		next unless $elem->[0] == 3;
		$elem = $elem->[1];
		last;
	}
	$elem = $elem->next_seq('extensions');
	$res->{altnames} = [];
	my $ext;
	while (!$elem->end && ($ext = $elem->next_seq('extension'))) {
		my $id = $ext->next_as('OBJECT IDENTIFIER', "Invalid certificate: found extension without an ID");
		next unless $id eq '2.5.29.17'; # subjectAltName

		my $next = $ext->next;
		# SMELL: we're violating the letter of X.509 here by not aborting when we find critical extensions we don't support
		$next = $ext->next if $ext->last eq 'BOOLEAN';
		confess "Invalid certificate: extension payload is not an octet string" unless $ext->last eq 'OCTET STRING';
		$ext = Local::DER->new($next);

		$ext = $ext->next_seq("subjectAltName list");
		my $gn;
		while (!$ext->end && ($gn = $ext->next_as('_apptag', "Invalid certificate: unexpected raw data in list of subjectAltNames"))) {
			next unless $gn->[0] == 2; # dNSName
			$gn = $gn->[1]->data;
			push @{$res->{altnames}}, $gn;
		}
	}
	$res;
}

package main;
# }}} X.509
# }}} Crypto and JWS fun
# ACME protocol {{{
sub _process_nonce {
	my $nonce = shift;
	return unless defined $nonce;
	trace "Received nonce: $nonce";
	die "invalid nonce from server" if $nonce =~ /[^0-9A-Za-z_-]/;
	return if grep $nonce, @nonces;
	push @nonces, $nonce;
}
sub _acme_response {
	my $res = shift;
	_process_nonce($res->header('replay-nonce'));

	trace "HTTP Response ------------------------------------\n". $res->as_string .
		"--------------------------------------------------";
	$res;
}
sub _acme_fail {
	my $res = shift;

	if ($res->is_error) {
		putdata('error', "Error from server: %s", $res->status_line);
		exit(1) if (($res->header('client-warning') // '') eq 'Internal response');
		my $err = decode_json($res->decoded_content);
		putdata('error-json', "Error details: %s", $err->{detail});
		exit(1);
	}
}
sub _acme_plain {
	my $url = shift;
	trace "Fetching info from: $url";
	my $res = $ua->get($url);
	_acme_response($res);
}
sub _acme {
	my $url = shift;

	unless (@nonces) {
		trace "Requesting new nonce by retrieving directory";
		_acme_plain($directory);
	}

	my $msg = jws_nonce(@_);
	trace "Sending to: $url";
	my $res = $ua->post($url, Content => $msg);
	_acme_response($res);
}
sub _acme_link {
	my ($res, $type) = @_;
	my @links = $res->header('link');
	my ($link) = grep /;rel="\Q$type\E"/, @links;
	return unless $link;
	$link =~ m#^<(https://.*?)>#;
	die "Error: could not parse link of type '$type'" unless $1;
	$1;
}
sub acme {
	my $url = shift;
	return _acme($url, @_) if @_;
	_acme_plain($url);
}
sub acme_directory {
	info "Fetching directory";
	my $res = acme($directory);
	_acme_fail($res);
	%resources = %{decode_json($res->decoded_content)};
}
sub acme_new {
	my $resource = shift;
	acme_directory() unless exists $resources{$resource};
	die "unknown ACME resource: $resource" unless exists $resources{$resource};

	acme($resources{$resource}, resource => $resource, @_);
}
# }}}

Getopt::Long::Configure('bundling', 'require_order', 'pass_through');
# General options
GetOptions(
	'config|c=s'	=> \$config_dir,
	'verbose|v!'	=> \$verbose,
	'trace|t!'	=> \$trace,
	'machine|m!'	=> \$machine,
	'version'	=> sub { out "placme version $VERSION"; exit; },
);

$keyfile = File::Spec->catfile($config_dir, 'account_key.pem');
if (-f cfgfile('directory')) {
	$directory = cfgslurp('directory');
} else {
	$directory = 'https://acme-v01.api.letsencrypt.org/directory';
}
$ua->show_progress(1) if $verbose;

$friendlyjson = JSON->new->utf8;
$friendlyjson->pretty->canonical unless $machine;

# Plumbing (base blocks of low-level implementation) {{{
sub initconf {
	my %opts = @_;
	my $parent = getparentdir($config_dir);
	make_path($parent);
	make_path($config_dir, { mode => 0700 });
	1;
}
sub chconf {
	my %opts = @_;
	while (my ($k, $v) = each(%opts)) {
		cfgspurt($k, $v);
	}
}
sub mkkey {
	my %opts = @_;
	my $bits = $opts{bits};
	openssl(undef, 'genpkey',
		-algorithm => 'RSA',
		-out => $keyfile,
		-pkeyopt => "rsa_keygen_bits:$bits"
	);
	!$exit;
}
sub _badresponse {
	my $res = shift;
	my $msg = shift || "Unexpected response from server";
	return {
		res => 0,
		msg => "$msg",
		response => $res,
	};
}
sub _badbail {
	my $res = shift;
	return if $res->{res};
	putdata('error', '%s', $res->{msg});
	my $resp;
	if (($res->{response}->header('client-warning') // '') eq 'Internal response') {
		$resp = {
			response => $res->{response}->as_string
		};
	} else {
		$resp = decode_json($res->{response}->decoded_content);
	}
	putdata('error-json', 'Error details: %s', $friendlyjson->encode($resp));
	exit;
}
sub _goodresponse {
	my $res = shift;
	my $data = decode_json($res->decoded_content);
	return {
		res => 1,
		url => $res->header('location') // undef,
		data => $data,
		rawdata => $friendlyjson->encode($data),
		@_,
	};
}
sub reg {
	my %opts = @_;
	my $res = acme_new('new-reg',
		contact => $opts{contacts},
	);
	return _badresponse($res) unless $res->code eq '201';
	_goodresponse($res,
		tos => _acme_link($res, 'terms-of-service'),
	);
}
sub updatereg {
	my %opts = @_;
	my $res = acme(delete $opts{reg},
		resource => 'reg',
		%opts,
	);
	return _badresponse($res) unless $res->code eq '202';
	_goodresponse($res,
		tos => _acme_link($res, 'terms-of-service')
	);
}
sub authz {
	my %opts = @_;
	my $res = acme_new('new-authz',
		identifier => {
			type => 'dns',
			value => $opts{domain},
		},
	);
	return _badresponse($res) unless $res->code eq '201';
	my $obj = decode_json($res->decoded_content);
	my $ch_http = grep { $_->{type} eq 'http-01' } @{$obj->{challenges}};
	_goodresponse($res,
		status => $obj->{status},
	);
}
sub getauthz {
	my %opts = @_;
	my $res = acme($opts{url});
	return _badresponse($res) unless $res->code =~ /^20[02]$/;
	my $obj = decode_json($res->decoded_content);
	_goodresponse($res,
		authzurl => _acme_link($res, 'up') // undef,
		code => $res->code,
		status => $obj->{status},
		delay => $res->header('retry-after') // undef,
	);
}
sub confirm {
	my %opts = @_;
	my $res = acme($opts{url},
		resource => 'challenge',
		type => $opts{type},
		keyAuthorization => "$opts{token}.$opts{thumb}",
	);
	return _badresponse($res) unless $res->code =~ /^20[02]$/;
	my $obj = decode_json($res->decoded_content);
	_goodresponse($res,
		authzurl => _acme_link($res, 'up') // undef,
		code => $res->code,
		status => $obj->{status},
		delay => $res->header('retry-after') // undef,
	);
}

#}}}

my %ops; %ops = (
	help => sub { #{{{
		pod2usage(-exitval => 0, -verbose => 1,
			-message => "Showing summary, use help --full for more."
		) if (!@ARGV);
		pod2usage(-exitval => 0, -verbose => 2) if $ARGV[0] eq '--full';
		pod2usage(-exitval => 0, -verbose => 99, -sections => "OPERATIONS/$ARGV[0]");
	}, # }}}
	bootstrap => sub { #{{{
		$ops{initconf}->();
		$ops{mkkey}->();
		$ops{reg}->();
		exit;
	}, #}}}
	initconf => sub { #{{{
		GetOptions(
			'directory|d=s' => \$directory,
		);
		if (!-d $config_dir) {
			initconf(directory => $directory);
			putdata('initconf-done', 'Config dir created: %s', $config_dir);
		}
		chconf(directory => $directory) if $directory;
	}, #}}}
	mkkey => sub { #{{{
		my $bits = 2048;
		GetOptions(
			'bits|b=i' => \$bits,
		);
		-f $keyfile && die "mkkey: account_key.pem already exists";
		my $res = mkkey(bits => $bits);
		die "mkkey: generation failed" unless $res;
		putdata('mkkey-done', 'Account key created: %s', $keyfile);
	}, #}}}
	reg => sub { #{{{
		if (-f cfgfile('registration')) {
			out "Registration already exists, aborting";
			exit(1);
		}
		my (@contacts, $autoagree);
		GetOptions(
			'autoagree!' => \$autoagree,
			'contact=s' => \@contacts,
		);
		pod2usage("reg: no contact(s) given") unless @contacts;
		m_progress('reg');
		my $res = reg(contact => \@contacts);
		_badbail($res);
		putdata('regurl', 'Registration successful, stored at %s', $res->{url});
		cfgspurt('registration', $res->{url});
		if ($res->{tos}) {
			if ($autoagree) {
				info "Automatically agreeing to TOS (tsk, tsk)";
				@ARGV = ("--agreement=$res->{tos}");
				$ops{updatereg}->();
				exit;
			}
			noise "Depending on the server's policies, you may need to agree to the TOS";
			noise "by running: placme updatereg --agreement=$res->{tos}";
		}
		putdata('tosurl', 'Link to terms of service: %s', $res->{tos}) if $res->{tos};
		putdata(-v => 'reg', 'Full registration data follows: %s', $res->{rawdata});
	}, #}}}
	updatereg => sub { #{{{
		my $reg = cfgslurp('registration');
		my ($agreement, @contacts);
		GetOptions(
			'agreement=s' => \$agreement,
			'contact=s' => \@contacts,
		);
		my %payload;
		$payload{agreement} = $agreement if $agreement;
		$payload{contact} = \@contacts if @contacts;
		m_progress('updatereg');
		my $res = updatereg(reg => $reg, %payload);
		_badbail($res);
		if ($res->{tos} && (!$res->{data}{agreement} || $res->{data}{agreement} ne $res->{tos})) {
			out "URL for terms of service which you have not accepted yet: $res->{tos}";
			out "Use updatereg --agreement=<URL> to confirm agreement.";
			putdata('tosurl', "URL for terms of service which you have not accepted yet: %s\nUse updatereg --agreement=<URL> to confirm agreement.", $res->{tos} || '');
		}
		putdata(-v => 'reg', 'Registration data updated: %s', $res->{rawdata});
	}, #}}}
	authz => sub { #{{{
		my ($auto_http, $domain);
		GetOptions(
			'http|h:s' => \$auto_http,
			'domain|d=s' => \$domain,
		);
		pod2usage("authz: need domain parameter") unless $domain;
		m_progress('authz');
		my $res = authz(domain => $domain);
		_badbail($res);
		noise "Authorization is now pending.";
		putdata('authzuri', 'Authorization info available here: %s', $res->{url});
		putdata(-v => 'authz', 'Current data about authorization: %s', $res->{rawdata});
		exit unless defined $auto_http;

		unless ($res->{status} eq 'pending') {
			out "authz: authorization response from server is not marked as pending.";
			out "Please manually review the response:";
			out $res->{rawdata};
			exit(1);
		}
		my ($ch_http) = grep { $_->{type} eq 'http-01' } @{$res->{data}{challenges}};
		unless ($ch_http) {
			out "authz: no HTTP challenge found in authorization response";
			out "Please manually review the response:";
			out $res->{rawdata};
			exit(1);
		}
		unshift(@ARGV,
			"--token=$ch_http->{token}",
			"--type=$ch_http->{type}",
		);
		unshift(@ARGV,
			"--url=$ch_http->{uri}",
		) if $auto_http eq 'send';
		putdata('chtoken', 'HTTP challenge token: %s', $ch_http->{token});
		putdata('churl', 'URL for submitting HTTP challenge: %s', $ch_http->{uri});
		$ops{confirm}->();
	}, #}}}
	confirm => sub { #{{{
		my ($url, $token, $wait, $in, $send, $skip_keyauth, $keyauth_out, $keyauth_dir);
		my $type = 'http-01';
		GetOptions(
			'url|u=s' => \$url,
			'type|T=s' => \$type,
			'token|t=s' => \$token,
			'skip-keyauth|K' => \$skip_keyauth,
			'keyauth-out|o=s' => \$keyauth_out,
			'keyauth-dir|O=s' => \$keyauth_dir,
			'wait|w=i' => \$wait,
		);
		pod2usage("confirm: requires --token=...") unless $token;

		my $thumb = jwk_thumbprint();
		unless ($skip_keyauth) {
			if (!$keyauth_out && $type eq 'http-01') {
				noise "Put the key authorization string in a file in the web root for your domain";
				noise "using the following name:";
				noise ".well-known/acme-challenge/$token";
			}
			if ($keyauth_dir) {
				spurt(File::Spec->catfile($keyauth_dir, $token), "$token.$thumb");
			} elsif ($keyauth_out) {
				$keyauth_out =~ s!:TOKEN:!$token!g;
				spurt($keyauth_out, "$token.$thumb");
			} else {
				putdata('keyauth', 'Key authorization string for the challenge: %s', "$token.$thumb");
			}
			exit unless $url;
		}
		pod2usage("confirm: need --url=...") unless $url;

		my $res = confirm(
			url => $url,
			type => $type,
			token => $token,
			thumb => $thumb,
		);
		_badbail($res);
		my $authz_url = $res->{authzurl};
		putdata(-v => 'authzurl', 'Authorization info URL: %s', $res->{authzurl});
		putdata(-v => 'challengeurl', 'Challenge info URL: %s', $res->{url});
		my $first_try = time;
		my $checkauthz; $checkauthz = sub {
			_badbail($res);
			if ($res->{code} eq '200') {
				putdata(-v => 'authz', 'Authorization data: %s', $res->{rawdata});
				exit if $res->{status} eq 'active';
				exit(1);
			} elsif ($res->{code} eq '202') {
				if (time - $first_try > $wait) {
					out "Wait timeout exceeded, please check manually later.";
					exit(1);
				}
				my $delay = $res->{delay} || 5;
				info "Waiting $delay seconds to re-check...";
				sleep($delay);
				$res = getauthz(url => $res->{authzurl});
				$checkauthz->();
			} else {
				confess "Bug in placme, please report";
			}
		};
		if ($wait) {
			$checkauthz->();
		} else {
			putdata('authz', 'Authorization data: %s', $res->{rawdata});
		}
	}, #}}}
	cert => sub { #{{{
		my ($csr, $key, $out);
		GetOptions(
			'csr|c:s' => \$csr,
			'key|k=s' => \$key,
			'out|o=s' => \$out,
		);
		# TODO change interface to use a single --in and autodetect type
		my @domains = @ARGV;
		pod2usage("cert: need --csr or --key") unless defined($csr) || $key;
		pod2usage("cert: --csr and --key are mutually exclusive") if $csr && $key;
		if ($out && (-f $out && !-w $out || !-w getdir($out))) {
			die "cert: desired output file '$out' seems unwritable";
		}
		if (defined $csr) {
			if ($csr ne '' && $csr ne '-') {
				$csr = slurp($csr);
			} else {
				local $/;
				$csr = <STDIN>;
			}
			$csr = Local::DER->new($csr, 'certificate request');
			$csr = encode_base64url($csr->data);
		} else {
			pod2usage("cert: need list of domains") unless @domains;
			$csr = mkreq($key, @domains);
		}
		my $res = acme_new('new-cert',
			csr => $csr,
		);
		if ($res->code eq '201') {
			$res = Local::DER::to_pem($res->decoded_content, 'certificate');
			if ($out) {
				spurt($out, $res);
			} else {
				print $res;
			}
		} else {
			out "cert: certificate request accepted but certificate not ready yet.";
			out "This case is not currently supported by placme.";
			out sprintf("Please fetch the certificate yourself at this location after ~%s seconds:", $res->header('retry-after') // 'many');
			out $res->header('location');
			exit(1);
		}
	}, #}}}
	revoke => sub { #{{{
		my $in;
		GetOptions(
			'in|i=s' => \$in,
		);
		if ($in) {
			$in = slurp($in);
		} else {
			local $/;
			$in = <STDIN>;
		}
		$in = Local::DER->new($in, 'certificate')->data;
		my $res = acme_new('revoke-cert',
			certificate => encode_base64url($in),
		);
		if ($res->code eq '200') {
			noise "Certificate revoked.";
			exit;
		}
		die "revoke: unexpected result from server: ". $res->decoded_content;
	}, # }}}
	certinfo => sub { #{{{
		my $in = shift @ARGV;
		if ($in) {
			$in = slurp($in);
		} else {
			local $/;
			$in = <STDIN>;
		}
		$in = Local::DER->new($in, 'certificate');
		$in = $in->cert_info;
		print $friendlyjson->encode($in);
	}, #}}}
);

my $op = shift @ARGV;
pod2usage("No operation specified") unless defined $op && $op ne '';
pod2usage("Unknown operation '$op'") unless exists $ops{$op};

$ops{$op}->();
exit;

# Manual {{{
__END__

=head1 NAME

placme - Perl client for the ACME protocol (used by e.g. Let's Encrypt)

=head1 SYNOPSIS

 placme --version
 placme help [<command>|--full]
 placme [options] <operation> [<operation options>] 
 
 placme bootstrap --contact=mailto:me@example.org
 placme updatereg --agreement=...
 placme authz --http=send --domain=<domain> --wait=30
     --keyauth-dir=/www/<domain>/.well-known/acme-challenge
 placme cert --key=<tls.key> <domain>...

=head1 OPTIONS

These are general options available to all operations, passed before the
operation name.

=over 4

=item B<--config=..., -c ...>

Sets a path to store configuration and persistent data for an
account. Defaults to F<~/.config/placme>.

If you want to use multiple accounts, you should use multiple config
directories, too.

=item B<--machine, -m>

Turns on machine-readable output: all bits of data are printed one per line
in the format "type E<lt>spaceE<gt> data", where "type" is a keyword that
describes what data is being output. "type", as well as the format of the data
following it, is guaranteed to never change in a future release of placme.

=item B<--quiet, -q>

Reduces output to the absolute minimum (only things absolutely needed to
continue to the next step.

=item B<--trace, -t>

Enables trace mode: information about all executed sub-processes and
protocol messages will be displayed.

=item B<--verbose, -v>

Enables informational output and some progress indicators.

=item B<--version>

Shows the placme version and exits.

=back

=head2 High-level commands

 bootstrap   Creates a new config directory with a private key, and
             registers an account.
 addcert     Adds a (not yet created) certificate to the registry.
 auto        Makes sure all of your registered certificates are created
             and/or updated, using the HTTP challenge method.
 rmcert      Revokes, deregisters and deletes a certificate.

=head2 Low-level commands

 initconf    Creates a new config directory.
 mkkey       Creates a private key in the config directory.
 reg         Registers an account for the private key.
 updatereg   Queries/updates an existing registration.
 authz       Requests authorization for a domain name.
 confirm     Submits confirmation that the challenge for an authorization
             has been fulfilled.
 cert        Requests a certificate for a set of authorized domain names.
 revoke      Requests revocation of a certificate.

=head1 OPERATIONS

=head2 bootstrap

Runs initconf, mkkey, and reg (creates the config directory wih a keypair and
registers an account using that keypair).

It accepts all corresponding options, but they need to be specified in the
correct order (as listed below).

=head3 Options

=over 4

=item B<--directory=..., -d ...>

Sets the URL where the ACME server's resource directory can be queried.
C<initconf> can be run again later to change this.

If not set, the letsencrypt.org ACME server will be used.

=item B<--bits=...>

The size of the key, defaults to 2048. My personal understanding is that
smaller values are considered to be somewhat insecure and that the benefit to
bigger values is not nearly as much as you might think. If you care, look it
up.

=item B<--contact=I<URI>>

Specifies a contact to be associated with the account. It may be given
multiple times.

This information is typically held private by the ACME server and it's a
really good idea to specify at least one e-mail address
(C<mailto:foo@example.org>). For this reason, placme requires at least one
instance of this option, even if the server does not.

=item B<--autoagree>

Automatically agree to the terms of service. Legally speaking, this is
probably not a good idea. You can manually agree to the terms of service using
the C<updatereg> operation.

=back

=head2 initconf

Creates the config directory (if it does not already exist).

The config directory will be readable only for the current user by default,
for security reasons (but parents automatically created by C<initconf> will
have permissions according to your umask). Feel free to change its mode but do
so at your own risk.

=head3 Options

=over 4

=item B<--directory=..., -d ...>

Sets the URL where the ACME server's resource directory can be queried.
C<initconf> can be run again later to change this.

If not set, the letsencrypt.org ACME server will be used.

=back

=head2 mkkey

Creates an account keypair in the config directory, with the name
F<account_key.pem>. Only one keypair per config directory is supported.

=head3 Options

=over 4

=item B<--bits=...>

The size of the key, defaults to 2048. My personal understanding is that
smaller values are considered to be somewhat insecure and that the benefit to
bigger values is not nearly as much as you might think. If you care, look it
up.

=back

=head2 reg

Registers an account for the keypair in the config directory.

=head3 Options

=over 4

=item B<--contact=I<URI>>

Specifies a contact to be associated with the account. It may be given
multiple times.

This information is typically held private by the ACME server and it's a
really good idea to specify at least one e-mail address
(C<mailto:foo@example.org>). For this reason, placme requires at least one
instance of this option, even if the server does not.

=item B<--autoagree>

Automatically agree to the terms of service. Legally speaking, this is
probably not a good idea. You can manually agree to the terms of service using
the C<updatereg> operation.

=back

=head2 updatereg

Update your registration, changing the contacts or confirming your agreement
to the terms of service.

If you do not include any options that change your registration, placme will
simply query the full registration data and output it.

=head3 Options

=over 4

=item B<--agreement=...>

Set this to the URL of the server's terms of service (which placme outputs
when you register, or when you query your registration using C<updatereg>
without options) to tell the server that you agree with the TOS. The server
may be rejecting all the interesting operations if you do not send your
agreement to the TOS first.

=item B<--contact=...>

Just like during registration, you can use this one multiple times. If you use
it, all the previously registered contacts will be removed, so be sure to list
all contacts you want to have on your account.

=back

=head2 authz

Requests authorization for a domain. If successful, placme will output the
authorization URL (for polling its status), followed by a newline and then, in
JSON format, the server's challenge data that tells you how to demonstrate
that you should be authorized to request certificates for that domain.

=head3 Options

=over 4

=item B<--domain=I<domain>, -d I<domain>>

The domain you want to get an authorization for.

=item B<--http[=send], -h [send]>

Include this to automatically begin responding to an HTTP-based challenge
(http-01). This will automatically forward the type, token and challenge URL
to the C<confirm> command (but the URL will only be included if you include
the C<=send>). You can pass any of C<confirm>'s options after C<authz>'s
options, though of course you'll want to leave out C<--type>, C<--token> and
C<--url>.

To automatically extract the token and URL for the HTTP challenge and
generate the keyauth string, use C<--http>.

To also place the keyauth file in a specific directory (e.g.
F</www/example.org/.well-known/acme-challenge>) and directly let the ACME
server verify it, use C<--keyauth-dir=...> (see the C<confirm> command) and
C<--http=send>. (You may want to also include C<confirm>'s C<--wait=...> to
wait for the server's verdict.)

=head2 confirm

Prepares (and optionally submits) confirmation of the challenge.

For HTTP (the only option fully supported by placme right now), this involves
putting a file at a special location with special content. If you have write
access to the correct location while running placme, you can automatically
have it put the challenge file there and send confirmation to the server.

If you want to use something other than HTTP, you can still use this operation
to generate the I<key authorization> string used by most of the challenge
types in ACME (e.g. TLS SNI and DNS), though you'll have to do the rest of the
work yourself until ACME adds more support for those.

Once the server has accepted your authorization(s), you can use the C<cert>
operation to request a certificate for any domains you are authorized for.

=head3 Options

=over 4

=item B<--type=..., -T ...>

The type of challenge to confirm, taken from the corresponding challenge
record. Defaults to C<http-01>.

=item B<--token=..., -t ...>

The challenge token.

=item B<--url=..., -u ...>

The URL to send confirmation to, as included in the challenge data. If you
leave this out, confirmation will not be sent to the server. You would leave
out the URL if you want to generate the key authorization and need to do some
additional preparation work before you actually let the server know you're
ready. Simply use C<confirm> again when you're done and pass the URL then.

=item B<--skip-keyauth, -K>

Skip generation of key authorization output. You can use this for a bit less
noise if you have already fulfilled the challenge and are calling C<confirm>
for the second time.

=item B<--keyauth-out=..., -o ...>

Where to write the I<key authorization> string to.

You can use the special placeholder C<:TOKEN:> in this path to have it
replaced with the challenge token (in case you're sending confirmation at the
same time you're generating the key authorization), since that is what's
required for HTTP-based challenges. Or you can simply use the B<--keyauth-dir>
option below.

=item B<--keyauth-dir=..., -O ...>

Use this instead of B<--keyauth-out> to simply specify a directory into which
the key authorization file will be placed with the correct name.

=item B<--wait=..., -w ...>

Wait this many seconds for the server to accept the challenge and mark the
authorization as valid. If you leave this out, you will have to poll the
authorization URL yourself.

=back

=head2 cert

Requests a certificate for a CSR or a key and list of domains. (The protocol
allows for certificates for arbitrary IDs, but for the sake of simplicity
placme uses only domain names (without any pesky protocol-like prefixes).

The list of domains you pass (either via the command line, or via a
pre-prepared CSR) must have valid authorizations on your account; otherwise
unhelpful things are likely to happen.

=head3 Options

=over 4

=item B<--key=..., -k ...>

Location of a private key to use as basis for the CSR, in PEM format. If you
do not use this, use C<--csr=...> instead; see below.

=item B<--csr=..., -c ...>

Use this to pass a pre-generated CSR file (in PEM format) that will be sent to
the ACME server. If you do not use this, use C<--key=...> instead; see above.

=item B<--out=..., -o ...>

Name of the file placme will write the certificate to (if all goes well). If
you leave this out, the certificate will be written to C<stdout>.

=item B<I<domain>...>

A list of domain names to be included in the CSR as subjectAltNames. The first
name in the list will be set as the common name (CN) in the certificate. The
ACME server may change the list of domain names (and the CN) in the final
certificate. The server may reject your request or filter names from these
list if you have no authorization for any of them.

This has no effect if you supply your own CSR.

=back

=head2 revoke

Revokes a previously issued certificate. Expects the name of a certificate
file as its parameter, or the certificate data via standard input.

=head1 LIMITATIONS

placme does not support account recovery keys. Please make sure to keep a
secure backup copy of your account key.

Some other operations are not supported, either. For example, placme does not
provide any support of its own for C<tls-sni-01> or C<dns> challenges, beyond
generating the key authorization string used in these methods.

placme's error handling is trigger-happy: it will often exit with a somewhat
generic message and a generic exit code. In many of these cases it might be
possible to provide more details about the error and its causes. If you have
any suggestions (perhaps even with patches), just let me know.

placme does not do any fancy security things, such as preventing private key
data from being swapped out of memory. It may be worthwhile running it on a
more or less isolated system to prevent any catastrophic leakage of sensitive
data (e.g. your account key).

=cut

